// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see
// https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/gimbal_manager_server/gimbal_manager_server.proto)

#include "gimbal_manager_server/gimbal_manager_server.grpc.pb.h"
#include "plugins/gimbal_manager_server/gimbal_manager_server.h"

#include "mavsdk.h"

#include "lazy_server_plugin.h"

#include "log.h"
#include <atomic>
#include <cmath>
#include <future>
#include <limits>
#include <memory>
#include <sstream>
#include <vector>

namespace mavsdk {
namespace mavsdk_server {

template<
    typename GimbalManagerServer = GimbalManagerServer,
    typename LazyServerPlugin = LazyServerPlugin<GimbalManagerServer>>

class GimbalManagerServerServiceImpl final
    : public rpc::gimbal_manager_server::GimbalManagerServerService::Service {
public:
    GimbalManagerServerServiceImpl(LazyServerPlugin& lazy_plugin) : _lazy_plugin(lazy_plugin) {}

    template<typename ResponseType>
    void fillResponseWithResult(
        ResponseType* response, mavsdk::GimbalManagerServer::Result& result) const
    {
        auto rpc_result = translateToRpcResult(result);

        auto* rpc_gimbal_manager_server_result =
            new rpc::gimbal_manager_server::GimbalManagerServerResult();
        rpc_gimbal_manager_server_result->set_result(rpc_result);
        std::stringstream ss;
        ss << result;
        rpc_gimbal_manager_server_result->set_result_str(ss.str());

        response->set_allocated_gimbal_manager_server_result(rpc_gimbal_manager_server_result);
    }

    static std::unique_ptr<rpc::gimbal_manager_server::Quaternion>
    translateToRpcQuaternion(const mavsdk::GimbalManagerServer::Quaternion& quaternion)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::Quaternion>();

        rpc_obj->set_w(quaternion.w);

        rpc_obj->set_x(quaternion.x);

        rpc_obj->set_y(quaternion.y);

        rpc_obj->set_z(quaternion.z);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::Quaternion
    translateFromRpcQuaternion(const rpc::gimbal_manager_server::Quaternion& quaternion)
    {
        mavsdk::GimbalManagerServer::Quaternion obj;

        obj.w = quaternion.w();

        obj.x = quaternion.x();

        obj.y = quaternion.y();

        obj.z = quaternion.z();

        return obj;
    }

    static std::unique_ptr<rpc::gimbal_manager_server::Information>
    translateToRpcInformation(const mavsdk::GimbalManagerServer::Information& information)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::Information>();

        rpc_obj->set_cap_flags(information.cap_flags);

        rpc_obj->set_gimbal_device_id(information.gimbal_device_id);

        rpc_obj->set_roll_min(information.roll_min);

        rpc_obj->set_roll_max(information.roll_max);

        rpc_obj->set_pitch_min(information.pitch_min);

        rpc_obj->set_pitch_max(information.pitch_max);

        rpc_obj->set_yaw_min(information.yaw_min);

        rpc_obj->set_yaw_max(information.yaw_max);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::Information
    translateFromRpcInformation(const rpc::gimbal_manager_server::Information& information)
    {
        mavsdk::GimbalManagerServer::Information obj;

        obj.cap_flags = information.cap_flags();

        obj.gimbal_device_id = information.gimbal_device_id();

        obj.roll_min = information.roll_min();

        obj.roll_max = information.roll_max();

        obj.pitch_min = information.pitch_min();

        obj.pitch_max = information.pitch_max();

        obj.yaw_min = information.yaw_min();

        obj.yaw_max = information.yaw_max();

        return obj;
    }

    static std::unique_ptr<rpc::gimbal_manager_server::GimbalManagerConfiguration>
    translateToRpcGimbalManagerConfiguration(
        const mavsdk::GimbalManagerServer::GimbalManagerConfiguration& gimbal_manager_configuration)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::GimbalManagerConfiguration>();

        rpc_obj->set_sysid_primary_control(gimbal_manager_configuration.sysid_primary_control);

        rpc_obj->set_compid_primary_control(gimbal_manager_configuration.compid_primary_control);

        rpc_obj->set_sysid_secondary_control(gimbal_manager_configuration.sysid_secondary_control);

        rpc_obj->set_compid_secondary_control(
            gimbal_manager_configuration.compid_secondary_control);

        rpc_obj->set_gimbal_device_id(gimbal_manager_configuration.gimbal_device_id);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::GimbalManagerConfiguration
    translateFromRpcGimbalManagerConfiguration(
        const rpc::gimbal_manager_server::GimbalManagerConfiguration& gimbal_manager_configuration)
    {
        mavsdk::GimbalManagerServer::GimbalManagerConfiguration obj;

        obj.sysid_primary_control = gimbal_manager_configuration.sysid_primary_control();

        obj.compid_primary_control = gimbal_manager_configuration.compid_primary_control();

        obj.sysid_secondary_control = gimbal_manager_configuration.sysid_secondary_control();

        obj.compid_secondary_control = gimbal_manager_configuration.compid_secondary_control();

        obj.gimbal_device_id = gimbal_manager_configuration.gimbal_device_id();

        return obj;
    }

    static std::unique_ptr<rpc::gimbal_manager_server::DeviceAttitudeStatus>
    translateToRpcDeviceAttitudeStatus(
        const mavsdk::GimbalManagerServer::DeviceAttitudeStatus& device_attitude_status)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::DeviceAttitudeStatus>();

        rpc_obj->set_time_boot_ms(device_attitude_status.time_boot_ms);

        rpc_obj->set_flags(device_attitude_status.flags);

        rpc_obj->set_allocated_q(translateToRpcQuaternion(device_attitude_status.q).release());

        rpc_obj->set_angular_velocity_x(device_attitude_status.angular_velocity_x);

        rpc_obj->set_angular_velocity_y(device_attitude_status.angular_velocity_y);

        rpc_obj->set_angular_velocity_z(device_attitude_status.angular_velocity_z);

        rpc_obj->set_failure_flags(device_attitude_status.failure_flags);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::DeviceAttitudeStatus translateFromRpcDeviceAttitudeStatus(
        const rpc::gimbal_manager_server::DeviceAttitudeStatus& device_attitude_status)
    {
        mavsdk::GimbalManagerServer::DeviceAttitudeStatus obj;

        obj.time_boot_ms = device_attitude_status.time_boot_ms();

        obj.flags = device_attitude_status.flags();

        obj.q = translateFromRpcQuaternion(device_attitude_status.q());

        obj.angular_velocity_x = device_attitude_status.angular_velocity_x();

        obj.angular_velocity_y = device_attitude_status.angular_velocity_y();

        obj.angular_velocity_z = device_attitude_status.angular_velocity_z();

        obj.failure_flags = device_attitude_status.failure_flags();

        return obj;
    }

    static rpc::gimbal_manager_server::GimbalManagerServerResult::Result
    translateToRpcResult(const mavsdk::GimbalManagerServer::Result& result)
    {
        switch (result) {
            default:
                LogErr() << "Unknown result enum value: " << static_cast<int>(result);
            // FALLTHROUGH
            case mavsdk::GimbalManagerServer::Result::Unknown:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_UNKNOWN;
            case mavsdk::GimbalManagerServer::Result::Success:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_SUCCESS;
            case mavsdk::GimbalManagerServer::Result::InProgress:
                return rpc::gimbal_manager_server::
                    GimbalManagerServerResult_Result_RESULT_IN_PROGRESS;
            case mavsdk::GimbalManagerServer::Result::Busy:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_BUSY;
            case mavsdk::GimbalManagerServer::Result::Denied:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_DENIED;
            case mavsdk::GimbalManagerServer::Result::Error:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_ERROR;
            case mavsdk::GimbalManagerServer::Result::Timeout:
                return rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_TIMEOUT;
            case mavsdk::GimbalManagerServer::Result::WrongArgument:
                return rpc::gimbal_manager_server::
                    GimbalManagerServerResult_Result_RESULT_WRONG_ARGUMENT;
            case mavsdk::GimbalManagerServer::Result::NoSystem:
                return rpc::gimbal_manager_server::
                    GimbalManagerServerResult_Result_RESULT_NO_SYSTEM;
        }
    }

    static mavsdk::GimbalManagerServer::Result translateFromRpcResult(
        const rpc::gimbal_manager_server::GimbalManagerServerResult::Result result)
    {
        switch (result) {
            default:
                LogErr() << "Unknown result enum value: " << static_cast<int>(result);
            // FALLTHROUGH
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_UNKNOWN:
                return mavsdk::GimbalManagerServer::Result::Unknown;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_SUCCESS:
                return mavsdk::GimbalManagerServer::Result::Success;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_IN_PROGRESS:
                return mavsdk::GimbalManagerServer::Result::InProgress;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_BUSY:
                return mavsdk::GimbalManagerServer::Result::Busy;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_DENIED:
                return mavsdk::GimbalManagerServer::Result::Denied;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_ERROR:
                return mavsdk::GimbalManagerServer::Result::Error;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_TIMEOUT:
                return mavsdk::GimbalManagerServer::Result::Timeout;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_WRONG_ARGUMENT:
                return mavsdk::GimbalManagerServer::Result::WrongArgument;
            case rpc::gimbal_manager_server::GimbalManagerServerResult_Result_RESULT_NO_SYSTEM:
                return mavsdk::GimbalManagerServer::Result::NoSystem;
        }
    }

    static std::unique_ptr<rpc::gimbal_manager_server::GimbalManagerStatus>
    translateToRpcGimbalManagerStatus(
        const mavsdk::GimbalManagerServer::GimbalManagerStatus& gimbal_manager_status)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::GimbalManagerStatus>();

        rpc_obj->set_flags(gimbal_manager_status.flags);

        rpc_obj->set_gimbal_device_id(gimbal_manager_status.gimbal_device_id);

        rpc_obj->set_primary_control_sysid(gimbal_manager_status.primary_control_sysid);

        rpc_obj->set_primary_control_compid(gimbal_manager_status.primary_control_compid);

        rpc_obj->set_secondary_control_sysid(gimbal_manager_status.secondary_control_sysid);

        rpc_obj->set_secondary_control_compid(gimbal_manager_status.secondary_control_compid);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::GimbalManagerStatus translateFromRpcGimbalManagerStatus(
        const rpc::gimbal_manager_server::GimbalManagerStatus& gimbal_manager_status)
    {
        mavsdk::GimbalManagerServer::GimbalManagerStatus obj;

        obj.flags = gimbal_manager_status.flags();

        obj.gimbal_device_id = gimbal_manager_status.gimbal_device_id();

        obj.primary_control_sysid = gimbal_manager_status.primary_control_sysid();

        obj.primary_control_compid = gimbal_manager_status.primary_control_compid();

        obj.secondary_control_sysid = gimbal_manager_status.secondary_control_sysid();

        obj.secondary_control_compid = gimbal_manager_status.secondary_control_compid();

        return obj;
    }

    static std::unique_ptr<rpc::gimbal_manager_server::SetAttitude>
    translateToRpcSetAttitude(const mavsdk::GimbalManagerServer::SetAttitude& set_attitude)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::SetAttitude>();

        rpc_obj->set_flags(set_attitude.flags);

        rpc_obj->set_allocated_attitude_quaternion(
            translateToRpcQuaternion(set_attitude.attitude_quaternion).release());

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::SetAttitude
    translateFromRpcSetAttitude(const rpc::gimbal_manager_server::SetAttitude& set_attitude)
    {
        mavsdk::GimbalManagerServer::SetAttitude obj;

        obj.flags = set_attitude.flags();

        obj.attitude_quaternion = translateFromRpcQuaternion(set_attitude.attitude_quaternion());

        return obj;
    }

    static std::unique_ptr<rpc::gimbal_manager_server::RoiLocation>
    translateToRpcRoiLocation(const mavsdk::GimbalManagerServer::RoiLocation& roi_location)
    {
        auto rpc_obj = std::make_unique<rpc::gimbal_manager_server::RoiLocation>();

        rpc_obj->set_gimbal_id(roi_location.gimbal_id);

        rpc_obj->set_latitude_deg(roi_location.latitude_deg);

        rpc_obj->set_longitude_deg(roi_location.longitude_deg);

        rpc_obj->set_absolute_altitude_m(roi_location.absolute_altitude_m);

        return rpc_obj;
    }

    static mavsdk::GimbalManagerServer::RoiLocation
    translateFromRpcRoiLocation(const rpc::gimbal_manager_server::RoiLocation& roi_location)
    {
        mavsdk::GimbalManagerServer::RoiLocation obj;

        obj.gimbal_id = roi_location.gimbal_id();

        obj.latitude_deg = roi_location.latitude_deg();

        obj.longitude_deg = roi_location.longitude_deg();

        obj.absolute_altitude_m = roi_location.absolute_altitude_m();

        return obj;
    }

    grpc::Status SetInformation(
        grpc::ServerContext* /* context */,
        const rpc::gimbal_manager_server::SetInformationRequest* request,
        rpc::gimbal_manager_server::SetInformationResponse* response) override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            if (response != nullptr) {
                // For server plugins, this should never happen, they should always be
                // constructible.
                auto result = mavsdk::GimbalManagerServer::Result::Unknown;
                fillResponseWithResult(response, result);
            }

            return grpc::Status::OK;
        }

        if (request == nullptr) {
            LogWarn() << "SetInformation sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _lazy_plugin.maybe_plugin()->set_information(
            translateFromRpcInformation(request->information()));

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SubscribeDeviceDiscovered(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::gimbal_manager_server::SubscribeDeviceDiscoveredRequest* /* request */,
        grpc::ServerWriter<rpc::gimbal_manager_server::DeviceDiscoveredResponse>* writer) override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);
        auto subscribe_mutex = std::make_shared<std::mutex>();

        const mavsdk::GimbalManagerServer::DeviceDiscoveredHandle handle =
            _lazy_plugin.maybe_plugin()->subscribe_device_discovered(
                [this, &writer, &stream_closed_promise, is_finished, subscribe_mutex, &handle](
                    const mavsdk::GimbalManagerServer::Information device_discovered) {
                    rpc::gimbal_manager_server::DeviceDiscoveredResponse rpc_response;

                    rpc_response.set_allocated_device_discovered(
                        translateToRpcInformation(device_discovered).release());

                    std::unique_lock<std::mutex> lock(*subscribe_mutex);
                    if (!*is_finished && !writer->Write(rpc_response)) {
                        _lazy_plugin.maybe_plugin()->unsubscribe_device_discovered(handle);

                        *is_finished = true;
                        unregister_stream_stop_promise(stream_closed_promise);
                        stream_closed_promise->set_value();
                    }
                });

        stream_closed_future.wait();
        std::unique_lock<std::mutex> lock(*subscribe_mutex);
        *is_finished = true;

        return grpc::Status::OK;
    }

    grpc::Status SubscribeGimbalManagerConfigured(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::gimbal_manager_server::
            SubscribeGimbalManagerConfiguredRequest* /* request */,
        grpc::ServerWriter<rpc::gimbal_manager_server::GimbalManagerConfiguredResponse>* writer)
        override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);
        auto subscribe_mutex = std::make_shared<std::mutex>();

        const mavsdk::GimbalManagerServer::GimbalManagerConfiguredHandle handle =
            _lazy_plugin.maybe_plugin()->subscribe_gimbal_manager_configured(
                [this, &writer, &stream_closed_promise, is_finished, subscribe_mutex, &handle](
                    const mavsdk::GimbalManagerServer::GimbalManagerConfiguration
                        gimbal_manager_configured) {
                    rpc::gimbal_manager_server::GimbalManagerConfiguredResponse rpc_response;

                    rpc_response.set_allocated_gimbal_manager_config(
                        translateToRpcGimbalManagerConfiguration(gimbal_manager_configured)
                            .release());

                    std::unique_lock<std::mutex> lock(*subscribe_mutex);
                    if (!*is_finished && !writer->Write(rpc_response)) {
                        _lazy_plugin.maybe_plugin()->unsubscribe_gimbal_manager_configured(handle);

                        *is_finished = true;
                        unregister_stream_stop_promise(stream_closed_promise);
                        stream_closed_promise->set_value();
                    }
                });

        stream_closed_future.wait();
        std::unique_lock<std::mutex> lock(*subscribe_mutex);
        *is_finished = true;

        return grpc::Status::OK;
    }

    grpc::Status SubscribeDeviceAttitudeStatus(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::gimbal_manager_server::
            SubscribeDeviceAttitudeStatusRequest* /* request */,
        grpc::ServerWriter<rpc::gimbal_manager_server::DeviceAttitudeStatusResponse>* writer)
        override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);
        auto subscribe_mutex = std::make_shared<std::mutex>();

        const mavsdk::GimbalManagerServer::DeviceAttitudeStatusHandle handle =
            _lazy_plugin.maybe_plugin()->subscribe_device_attitude_status(
                [this, &writer, &stream_closed_promise, is_finished, subscribe_mutex, &handle](
                    const mavsdk::GimbalManagerServer::DeviceAttitudeStatus
                        device_attitude_status) {
                    rpc::gimbal_manager_server::DeviceAttitudeStatusResponse rpc_response;

                    rpc_response.set_allocated_device_attitude_status(
                        translateToRpcDeviceAttitudeStatus(device_attitude_status).release());

                    std::unique_lock<std::mutex> lock(*subscribe_mutex);
                    if (!*is_finished && !writer->Write(rpc_response)) {
                        _lazy_plugin.maybe_plugin()->unsubscribe_device_attitude_status(handle);

                        *is_finished = true;
                        unregister_stream_stop_promise(stream_closed_promise);
                        stream_closed_promise->set_value();
                    }
                });

        stream_closed_future.wait();
        std::unique_lock<std::mutex> lock(*subscribe_mutex);
        *is_finished = true;

        return grpc::Status::OK;
    }

    grpc::Status GetGimbalManagerStatus(
        grpc::ServerContext* /* context */,
        const rpc::gimbal_manager_server::GetGimbalManagerStatusRequest* /* request */,
        rpc::gimbal_manager_server::GetGimbalManagerStatusResponse* response) override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto result = _lazy_plugin.maybe_plugin()->get_gimbal_manager_status();

        if (response != nullptr) {
            response->set_allocated_gimbal_manager_status(
                translateToRpcGimbalManagerStatus(result).release());
        }

        return grpc::Status::OK;
    }

    grpc::Status SubscribeSetAttitude(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::gimbal_manager_server::SubscribeSetAttitudeRequest* /* request */,
        grpc::ServerWriter<rpc::gimbal_manager_server::SetAttitudeResponse>* writer) override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);
        auto subscribe_mutex = std::make_shared<std::mutex>();

        const mavsdk::GimbalManagerServer::SetAttitudeHandle handle =
            _lazy_plugin.maybe_plugin()->subscribe_set_attitude(
                [this, &writer, &stream_closed_promise, is_finished, subscribe_mutex, &handle](
                    const mavsdk::GimbalManagerServer::SetAttitude set_attitude) {
                    rpc::gimbal_manager_server::SetAttitudeResponse rpc_response;

                    rpc_response.set_allocated_set_attitude(
                        translateToRpcSetAttitude(set_attitude).release());

                    std::unique_lock<std::mutex> lock(*subscribe_mutex);
                    if (!*is_finished && !writer->Write(rpc_response)) {
                        _lazy_plugin.maybe_plugin()->unsubscribe_set_attitude(handle);

                        *is_finished = true;
                        unregister_stream_stop_promise(stream_closed_promise);
                        stream_closed_promise->set_value();
                    }
                });

        stream_closed_future.wait();
        std::unique_lock<std::mutex> lock(*subscribe_mutex);
        *is_finished = true;

        return grpc::Status::OK;
    }

    grpc::Status SubscribeSetRoiLocation(
        grpc::ServerContext* /* context */,
        const mavsdk::rpc::gimbal_manager_server::SubscribeSetRoiLocationRequest* /* request */,
        grpc::ServerWriter<rpc::gimbal_manager_server::SetRoiLocationResponse>* writer) override
    {
        if (_lazy_plugin.maybe_plugin() == nullptr) {
            return grpc::Status::OK;
        }

        auto stream_closed_promise = std::make_shared<std::promise<void>>();
        auto stream_closed_future = stream_closed_promise->get_future();
        register_stream_stop_promise(stream_closed_promise);

        auto is_finished = std::make_shared<bool>(false);
        auto subscribe_mutex = std::make_shared<std::mutex>();

        const mavsdk::GimbalManagerServer::SetRoiLocationHandle handle =
            _lazy_plugin.maybe_plugin()->subscribe_set_roi_location(
                [this, &writer, &stream_closed_promise, is_finished, subscribe_mutex, &handle](
                    const mavsdk::GimbalManagerServer::RoiLocation set_roi_location) {
                    rpc::gimbal_manager_server::SetRoiLocationResponse rpc_response;

                    rpc_response.set_allocated_roi_location(
                        translateToRpcRoiLocation(set_roi_location).release());

                    std::unique_lock<std::mutex> lock(*subscribe_mutex);
                    if (!*is_finished && !writer->Write(rpc_response)) {
                        _lazy_plugin.maybe_plugin()->unsubscribe_set_roi_location(handle);

                        *is_finished = true;
                        unregister_stream_stop_promise(stream_closed_promise);
                        stream_closed_promise->set_value();
                    }
                });

        stream_closed_future.wait();
        std::unique_lock<std::mutex> lock(*subscribe_mutex);
        *is_finished = true;

        return grpc::Status::OK;
    }

    void stop()
    {
        _stopped.store(true);
        for (auto& prom : _stream_stop_promises) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        }
    }

private:
    void register_stream_stop_promise(std::weak_ptr<std::promise<void>> prom)
    {
        // If we have already stopped, set promise immediately and don't add it to list.
        if (_stopped.load()) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        } else {
            _stream_stop_promises.push_back(prom);
        }
    }

    void unregister_stream_stop_promise(std::shared_ptr<std::promise<void>> prom)
    {
        for (auto it = _stream_stop_promises.begin(); it != _stream_stop_promises.end();
             /* ++it */) {
            if (it->lock() == prom) {
                it = _stream_stop_promises.erase(it);
            } else {
                ++it;
            }
        }
    }

    LazyServerPlugin& _lazy_plugin;

    std::atomic<bool> _stopped{false};
    std::vector<std::weak_ptr<std::promise<void>>> _stream_stop_promises{};
};

} // namespace mavsdk_server
} // namespace mavsdk